<?php

/**
 * This file was generated by stellar_contract_bindings v0.5.0b0
 * and stellar_sdk v13.0.0.
 *
 * @generated
 */


declare(strict_types=1);

namespace Soneso\StellarSDKTests\bindings;

use Exception;
use GuzzleHttp\Exception\GuzzleException;
use Soneso\StellarSDK\Crypto\KeyPair;
use Soneso\StellarSDK\Soroban\Address;
use Soneso\StellarSDK\Soroban\Contract\AssembledTransaction;
use Soneso\StellarSDK\Soroban\Contract\ClientOptions;
use Soneso\StellarSDK\Soroban\Contract\ContractSpec;
use Soneso\StellarSDK\Soroban\Contract\MethodOptions;
use Soneso\StellarSDK\Soroban\Contract\SorobanClient;
use Soneso\StellarSDK\Xdr\XdrSCMapEntry;
use Soneso\StellarSDK\Xdr\XdrSCVal;
use Soneso\StellarSDK\Xdr\XdrSCValType;

/**
 * Generated contract client for AtomicSwapContract
 */
class AtomicSwapContract
{
    /**
     * The underlying SorobanClient instance
     * @var SorobanClient
     */
    private SorobanClient $client;

    /**
     * Private constructor that wraps a SorobanClient
     * @param SorobanClient $client
     */
    private function __construct(SorobanClient $client)
    {
        $this->client = $client;
    }

    /**
     * Creates a new AtomicSwapContract for the given contract ID
     * @param ClientOptions $options Client options for the contract
     * @return AtomicSwapContract
     * @throws Exception
     * @throws GuzzleException
     */
    public static function forClientOptions(ClientOptions $options): self
    {
        $client = SorobanClient::forClientOptions($options);
        return new self($client);
    }

    /**
     * Gets the contract ID
     * @return string
     */
    public function getContractId(): string
    {
        return $this->client->getContractId();
    }

    /**
     * Gets the client options
     * @return ClientOptions
     */
    public function getOptions(): ClientOptions
    {
        return $this->client->getOptions();
    }

    /**
     * Gets the contract specification
     * @return ContractSpec
     */
    public function getContractSpec(): ContractSpec
    {
        return $this->client->getContractSpec();
    }

    /**
     * Invoke the swap method
     *
     * @param Address $a
     * @param Address $b
     * @param Address $token_a
     * @param Address $token_b
     * @param string $amount_a
     * @param string $min_b_for_a
     * @param string $amount_b
     * @param string $min_a_for_b
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function swap(
        Address $a,
        Address $b,
        Address $token_a,
        Address $token_b,
        string $amount_a,
        string $min_b_for_a,
        string $amount_b,
        string $min_a_for_b,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $a->toXdrSCVal(),
            $b->toXdrSCVal(),
            $token_a->toXdrSCVal(),
            $token_b->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount_a),
            XdrSCVal::forI128BigInt($min_b_for_a),
            XdrSCVal::forI128BigInt($amount_b),
            XdrSCVal::forI128BigInt($min_a_for_b)
        ];

        $result = $this->client->invokeMethod(
            name: 'swap',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the swap method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $a
     * @param Address $b
     * @param Address $token_a
     * @param Address $token_b
     * @param string $amount_a
     * @param string $min_b_for_a
     * @param string $amount_b
     * @param string $min_a_for_b
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildSwapTx(
        Address $a,
        Address $b,
        Address $token_a,
        Address $token_b,
        string $amount_a,
        string $min_b_for_a,
        string $amount_b,
        string $min_a_for_b,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $a->toXdrSCVal(),
            $b->toXdrSCVal(),
            $token_a->toXdrSCVal(),
            $token_b->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount_a),
            XdrSCVal::forI128BigInt($min_b_for_a),
            XdrSCVal::forI128BigInt($amount_b),
            XdrSCVal::forI128BigInt($min_a_for_b)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'swap',
            args: $args,
            methodOptions: $methodOptions
        );
    }
}
