<?php

/**
 * This file was generated by stellar_contract_bindings v0.4.1b0
 * and stellar_sdk v13.0.0b0.
 * 
 * @generated
 */


declare(strict_types=1);

namespace Soneso\StellarSDKTests\bindings;

use Exception;
use GuzzleHttp\Exception\GuzzleException;
use Soneso\StellarSDK\Crypto\KeyPair;
use Soneso\StellarSDK\Soroban\Address;
use Soneso\StellarSDK\Soroban\Contract\AssembledTransaction;
use Soneso\StellarSDK\Soroban\Contract\ClientOptions;
use Soneso\StellarSDK\Soroban\Contract\ContractSpec;
use Soneso\StellarSDK\Soroban\Contract\MethodOptions;
use Soneso\StellarSDK\Soroban\Contract\SorobanClient;
use Soneso\StellarSDK\Xdr\XdrSCMapEntry;
use Soneso\StellarSDK\Xdr\XdrSCVal;
use Soneso\StellarSDK\Xdr\XdrSCValType;

/**
 * Generated union AuthContractDataKey
 */
class AuthContractDataKey
{
    public const COUNTER = 'Counter';

    public string $kind;
    public ?Address $counter = null;

    public function __construct(string $kind, ?Address $counter = null)
    {
        $this->kind = $kind;
        $this->counter = $counter;
    }

    public function toSCVal(): XdrSCVal
    {
        switch ($this->kind) {
            case self::COUNTER:
                return XdrSCVal::forVec([
                    XdrSCVal::forSymbol($this->kind),
                    $this->counter->toXdrSCVal()
                ]);
            default:
                throw new Exception("Invalid union kind: {$this->kind}");
        }
    }

    public static function fromSCVal(XdrSCVal $val): self
    {
        if ($val->vec === null || count($val->vec) < 1) {
            throw new Exception("Invalid union value: expected vec with at least 1 element");
        }
        
        $kind = $val->vec[0]->sym;
        
        switch ($kind) {
            case 'Counter':
                if (count($val->vec) !== 2) {
                    throw new Exception("Invalid union value for Counter: expected 2 elements");
                }
                return new self(
                    self::COUNTER,
                    counter: Address::fromXdrSCVal($val->vec[1])
                );
            default:
                throw new Exception("Unknown union kind: $kind");
        }
    }
}

/**
 * Generated contract client for AuthContract
 */
class AuthContract
{
    /**
     * The underlying SorobanClient instance
     * @var SorobanClient
     */
    private SorobanClient $client;

    /**
     * Private constructor that wraps a SorobanClient
     * @param SorobanClient $client
     */
    private function __construct(SorobanClient $client)
    {
        $this->client = $client;
    }

    /**
     * Creates a new AuthContract for the given contract ID
     * @param ClientOptions $options Client options for the contract
     * @return AuthContract
     * @throws Exception
     * @throws GuzzleException
     */
    public static function forClientOptions(ClientOptions $options): self
    {
        $client = SorobanClient::forClientOptions($options);
        return new self($client);
    }

    /**
     * Gets the contract ID
     * @return string
     */
    public function getContractId(): string
    {
        return $this->client->getContractId();
    }

    /**
     * Gets the client options
     * @return ClientOptions
     */
    public function getOptions(): ClientOptions
    {
        return $this->client->getOptions();
    }

    /**
     * Gets the contract specification
     * @return ContractSpec
     */
    public function getContractSpec(): ContractSpec
    {
        return $this->client->getContractSpec();
    }

    /**
     * Increment increments a counter for the user, and returns the value.
     *
     * @param Address $user
     * @param int $value
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return int
     * @throws Exception
     * @throws GuzzleException
     */
    public function increment(
        Address $user,
        int $value,
        ?MethodOptions $methodOptions = null
    ): int {
        $args = [
            $user->toXdrSCVal(),
            XdrSCVal::forU32($value)
        ];
        
        $result = $this->client->invokeMethod(
            name: 'increment',
            args: $args,
            methodOptions: $methodOptions
        );
        return $result->u32;
    }

    /**
     * Build an AssembledTransaction for the increment method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $user
     * @param int $value
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildIncrementTx(
        Address $user,
        int $value,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $user->toXdrSCVal(),
            XdrSCVal::forU32($value)
        ];
        
        return $this->client->buildInvokeMethodTx(
            name: 'increment',
            args: $args,
            methodOptions: $methodOptions
        );
    }
}