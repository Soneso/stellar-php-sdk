<?php

/**
 * This file was generated by stellar_contract_bindings v0.5.0b0
 * and stellar_sdk v13.0.0.
 *
 * @generated
 */


declare(strict_types=1);

namespace Soneso\StellarSDKTests\bindings;

use Exception;
use GuzzleHttp\Exception\GuzzleException;
use Soneso\StellarSDK\Crypto\KeyPair;
use Soneso\StellarSDK\Soroban\Address;
use Soneso\StellarSDK\Soroban\Contract\AssembledTransaction;
use Soneso\StellarSDK\Soroban\Contract\ClientOptions;
use Soneso\StellarSDK\Soroban\Contract\ContractSpec;
use Soneso\StellarSDK\Soroban\Contract\MethodOptions;
use Soneso\StellarSDK\Soroban\Contract\SorobanClient;
use Soneso\StellarSDK\Xdr\XdrSCMapEntry;
use Soneso\StellarSDK\Xdr\XdrSCVal;
use Soneso\StellarSDK\Xdr\XdrSCValType;

/**
 * Generated struct TokenContractAllowanceDataKey
 */
class TokenContractAllowanceDataKey
{
    public Address $from;
    public Address $spender;

    public function __construct(
        Address $from,
        Address $spender
    ) {
        $this->from = $from;
        $this->spender = $spender;
    }

    public function toSCVal(): XdrSCVal
    {
        $mapEntries = [];
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('from'),
            $this->from->toXdrSCVal()
        );
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('spender'),
            $this->spender->toXdrSCVal()
        );
        return XdrSCVal::forMap($mapEntries);
    }

    public static function fromSCVal(XdrSCVal $val): self
    {
        $map = [];
        foreach ($val->map as $entry) {
            $map[$entry->key->sym] = $entry->val;
        }
        return new self(
            from: Address::fromXdrSCVal($map["from"]),
            spender: Address::fromXdrSCVal($map["spender"])
        );
    }
}

/**
 * Generated struct TokenContractAllowanceValue
 */
class TokenContractAllowanceValue
{
    public string $amount;
    public int $expiration_ledger;

    public function __construct(
        string $amount,
        int $expiration_ledger
    ) {
        $this->amount = $amount;
        $this->expiration_ledger = $expiration_ledger;
    }

    public function toSCVal(): XdrSCVal
    {
        $mapEntries = [];
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('amount'),
            XdrSCVal::forI128BigInt($this->amount)
        );
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('expiration_ledger'),
            XdrSCVal::forU32($this->expiration_ledger)
        );
        return XdrSCVal::forMap($mapEntries);
    }

    public static function fromSCVal(XdrSCVal $val): self
    {
        $map = [];
        foreach ($val->map as $entry) {
            $map[$entry->key->sym] = $entry->val;
        }
        return new self(
            amount: gmp_strval($map["amount"]->toBigInt()),
            expiration_ledger: $map["expiration_ledger"]->u32
        );
    }
}

/**
 * Generated union TokenContractDataKey
 */
class TokenContractDataKey
{
    public const ALLOWANCE = 'Allowance', BALANCE = 'Balance', STATE = 'State', ADMIN = 'Admin';

    public string $kind;
    public ?TokenContractAllowanceDataKey $allowance = null;
    public ?Address $balance = null;
    public ?Address $state = null;

    public function __construct(string $kind, ?TokenContractAllowanceDataKey $allowance = null, ?Address $balance = null, ?Address $state = null)
    {
        $this->kind = $kind;
        $this->allowance = $allowance;
        $this->balance = $balance;
        $this->state = $state;
    }

    public function toSCVal(): XdrSCVal
    {
        switch ($this->kind) {
            case self::ALLOWANCE:
                return XdrSCVal::forVec([
                    XdrSCVal::forSymbol($this->kind),
                    $this->allowance->toSCVal()
                ]);
            case self::BALANCE:
                return XdrSCVal::forVec([
                    XdrSCVal::forSymbol($this->kind),
                    $this->balance->toXdrSCVal()
                ]);
            case self::STATE:
                return XdrSCVal::forVec([
                    XdrSCVal::forSymbol($this->kind),
                    $this->state->toXdrSCVal()
                ]);
            case self::ADMIN:
                return XdrSCVal::forVec([XdrSCVal::forSymbol($this->kind)]);
            default:
                throw new Exception("Invalid union kind: {$this->kind}");
        }
    }

    public static function fromSCVal(XdrSCVal $val): self
    {
        if ($val->vec === null || count($val->vec) < 1) {
            throw new Exception("Invalid union value: expected vec with at least 1 element");
        }

        $kind = $val->vec[0]->sym;

        switch ($kind) {
            case 'Allowance':
                if (count($val->vec) !== 2) {
                    throw new Exception("Invalid union value for Allowance: expected 2 elements");
                }
                return new self(
                    self::ALLOWANCE,
                    allowance: TokenContractAllowanceDataKey::fromSCVal($val->vec[1])
                );
            case 'Balance':
                if (count($val->vec) !== 2) {
                    throw new Exception("Invalid union value for Balance: expected 2 elements");
                }
                return new self(
                    self::BALANCE,
                    balance: Address::fromXdrSCVal($val->vec[1])
                );
            case 'State':
                if (count($val->vec) !== 2) {
                    throw new Exception("Invalid union value for State: expected 2 elements");
                }
                return new self(
                    self::STATE,
                    state: Address::fromXdrSCVal($val->vec[1])
                );
            case 'Admin':
                return new self(self::ADMIN);
            default:
                throw new Exception("Unknown union kind: $kind");
        }
    }
}

/**
 * Generated struct TokenContractTokenMetadata
 */
class TokenContractTokenMetadata
{
    public int $decimal;
    public string $name;
    public string $symbol;

    public function __construct(
        int $decimal,
        string $name,
        string $symbol
    ) {
        $this->decimal = $decimal;
        $this->name = $name;
        $this->symbol = $symbol;
    }

    public function toSCVal(): XdrSCVal
    {
        $mapEntries = [];
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('decimal'),
            XdrSCVal::forU32($this->decimal)
        );
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('name'),
            XdrSCVal::forString($this->name)
        );
        $mapEntries[] = new XdrSCMapEntry(
            XdrSCVal::forSymbol('symbol'),
            XdrSCVal::forString($this->symbol)
        );
        return XdrSCVal::forMap($mapEntries);
    }

    public static function fromSCVal(XdrSCVal $val): self
    {
        $map = [];
        foreach ($val->map as $entry) {
            $map[$entry->key->sym] = $entry->val;
        }
        return new self(
            decimal: $map["decimal"]->u32,
            name: $map["name"]->str,
            symbol: $map["symbol"]->str
        );
    }
}

/**
 * Generated contract client for TokenContract
 */
class TokenContract
{
    /**
     * The underlying SorobanClient instance
     * @var SorobanClient
     */
    private SorobanClient $client;

    /**
     * Private constructor that wraps a SorobanClient
     * @param SorobanClient $client
     */
    private function __construct(SorobanClient $client)
    {
        $this->client = $client;
    }

    /**
     * Creates a new TokenContract for the given contract ID
     * @param ClientOptions $options Client options for the TokenContract
     * @return TokenContract
     * @throws Exception
     * @throws GuzzleException
     */
    public static function forClientOptions(ClientOptions $options): self
    {
        $client = SorobanClient::forClientOptions($options);
        return new self($client);
    }

    /**
     * Gets the contract ID
     * @return string
     */
    public function getContractId(): string
    {
        return $this->client->getContractId();
    }

    /**
     * Gets the client options
     * @return ClientOptions
     */
    public function getOptions(): ClientOptions
    {
        return $this->client->getOptions();
    }

    /**
     * Gets the contract specification
     * @return ContractSpec
     */
    public function getContractSpec(): ContractSpec
    {
        return $this->client->getContractSpec();
    }

    /**
     * Invoke the mint method
     *
     * @param Address $to
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function mint(
        Address $to,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $to->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        $result = $this->client->invokeMethod(
            name: 'mint',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the mint method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $to
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildMintTx(
        Address $to,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $to->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'mint',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the set_admin method
     *
     * @param Address $new_admin
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function setAdmin(
        Address $new_admin,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $new_admin->toXdrSCVal()
        ];

        $result = $this->client->invokeMethod(
            name: 'set_admin',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the set_admin method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $new_admin
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildSetAdminTx(
        Address $new_admin,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $new_admin->toXdrSCVal()
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'set_admin',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the allowance method
     *
     * @param Address $from
     * @param Address $spender
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return string
     * @throws Exception
     * @throws GuzzleException
     */
    public function allowance(
        Address $from,
        Address $spender,
        ?MethodOptions $methodOptions = null
    ): string {
        $args = [
            $from->toXdrSCVal(),
            $spender->toXdrSCVal()
        ];

        $result = $this->client->invokeMethod(
            name: 'allowance',
            args: $args,
            methodOptions: $methodOptions
        );
        return gmp_strval($result->toBigInt());
    }

    /**
     * Build an AssembledTransaction for the allowance method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $from
     * @param Address $spender
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildAllowanceTx(
        Address $from,
        Address $spender,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $from->toXdrSCVal(),
            $spender->toXdrSCVal()
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'allowance',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the approve method
     *
     * @param Address $from
     * @param Address $spender
     * @param string $amount
     * @param int $expiration_ledger
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function approve(
        Address $from,
        Address $spender,
        string $amount,
        int $expiration_ledger,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $from->toXdrSCVal(),
            $spender->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount),
            XdrSCVal::forU32($expiration_ledger)
        ];

        $result = $this->client->invokeMethod(
            name: 'approve',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the approve method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $from
     * @param Address $spender
     * @param string $amount
     * @param int $expiration_ledger
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildApproveTx(
        Address $from,
        Address $spender,
        string $amount,
        int $expiration_ledger,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $from->toXdrSCVal(),
            $spender->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount),
            XdrSCVal::forU32($expiration_ledger)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'approve',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the balance method
     *
     * @param Address $id
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return string
     * @throws Exception
     * @throws GuzzleException
     */
    public function balance(
        Address $id,
        ?MethodOptions $methodOptions = null
    ): string {
        $args = [
            $id->toXdrSCVal()
        ];

        $result = $this->client->invokeMethod(
            name: 'balance',
            args: $args,
            methodOptions: $methodOptions
        );
        return gmp_strval($result->toBigInt());
    }

    /**
     * Build an AssembledTransaction for the balance method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $id
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildBalanceTx(
        Address $id,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $id->toXdrSCVal()
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'balance',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the transfer method
     *
     * @param Address $from
     * @param Address $to_muxed
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function transfer(
        Address $from,
        Address $to_muxed,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $from->toXdrSCVal(),
            $to_muxed->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        $result = $this->client->invokeMethod(
            name: 'transfer',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the transfer method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $from
     * @param Address $to_muxed
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildTransferTx(
        Address $from,
        Address $to_muxed,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $from->toXdrSCVal(),
            $to_muxed->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'transfer',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the transfer_from method
     *
     * @param Address $spender
     * @param Address $from
     * @param Address $to
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function transferFrom(
        Address $spender,
        Address $from,
        Address $to,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $spender->toXdrSCVal(),
            $from->toXdrSCVal(),
            $to->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        $result = $this->client->invokeMethod(
            name: 'transfer_from',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the transfer_from method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $spender
     * @param Address $from
     * @param Address $to
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildTransferFromTx(
        Address $spender,
        Address $from,
        Address $to,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $spender->toXdrSCVal(),
            $from->toXdrSCVal(),
            $to->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'transfer_from',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the burn method
     *
     * @param Address $from
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function burn(
        Address $from,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $from->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        $result = $this->client->invokeMethod(
            name: 'burn',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the burn method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $from
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildBurnTx(
        Address $from,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $from->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'burn',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the burn_from method
     *
     * @param Address $spender
     * @param Address $from
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return void
     * @throws Exception
     * @throws GuzzleException
     */
    public function burnFrom(
        Address $spender,
        Address $from,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): void {
        $args = [
            $spender->toXdrSCVal(),
            $from->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        $result = $this->client->invokeMethod(
            name: 'burn_from',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Build an AssembledTransaction for the burn_from method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param Address $spender
     * @param Address $from
     * @param string $amount
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildBurnFromTx(
        Address $spender,
        Address $from,
        string $amount,
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
            $spender->toXdrSCVal(),
            $from->toXdrSCVal(),
            XdrSCVal::forI128BigInt($amount)
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'burn_from',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the decimals method
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return int
     * @throws Exception
     * @throws GuzzleException
     */
    public function decimals(
        ?MethodOptions $methodOptions = null
    ): int {
        $args = [
        ];

        $result = $this->client->invokeMethod(
            name: 'decimals',
            args: $args,
            methodOptions: $methodOptions
        );
        return $result->u32;
    }

    /**
     * Build an AssembledTransaction for the decimals method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildDecimalsTx(
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'decimals',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the name method
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return string
     * @throws Exception
     * @throws GuzzleException
     */
    public function name(
        ?MethodOptions $methodOptions = null
    ): string {
        $args = [
        ];

        $result = $this->client->invokeMethod(
            name: 'name',
            args: $args,
            methodOptions: $methodOptions
        );
        return $result->str;
    }

    /**
     * Build an AssembledTransaction for the name method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildNameTx(
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'name',
            args: $args,
            methodOptions: $methodOptions
        );
    }

    /**
     * Invoke the symbol method
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return string
     * @throws Exception
     * @throws GuzzleException
     */
    public function symbol(
        ?MethodOptions $methodOptions = null
    ): string {
        $args = [
        ];

        $result = $this->client->invokeMethod(
            name: 'symbol',
            args: $args,
            methodOptions: $methodOptions
        );
        return $result->str;
    }

    /**
     * Build an AssembledTransaction for the symbol method.
     * This is useful if you need to manipulate the transaction before signing and sending.
     *
     * @param MethodOptions|null $methodOptions Options for transaction
     * @return AssembledTransaction
     * @throws Exception
     * @throws GuzzleException
     */
    public function buildSymbolTx(
        ?MethodOptions $methodOptions = null
    ): AssembledTransaction {
        $args = [
        ];

        return $this->client->buildInvokeMethodTx(
            name: 'symbol',
            args: $args,
            methodOptions: $methodOptions
        );
    }
}